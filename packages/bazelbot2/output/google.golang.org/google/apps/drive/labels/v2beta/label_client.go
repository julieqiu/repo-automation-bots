// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go_gapic. DO NOT EDIT.

package labels

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net/http"
	"net/url"

	gax "github.com/googleapis/gax-go/v2"
	"google.golang.org/api/googleapi"
	"google.golang.org/api/iterator"
	"google.golang.org/api/option"
	"google.golang.org/api/option/internaloption"
	gtransport "google.golang.org/api/transport/grpc"
	httptransport "google.golang.org/api/transport/http"
	labelspb "google.golang.org/genproto/googleapis/apps/drive/labels/v2beta"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

var newLabelClientHook clientHook

// LabelCallOptions contains the retry settings for each method of LabelClient.
type LabelCallOptions struct {
	GetUserCapabilities         []gax.CallOption
	ListLabels                  []gax.CallOption
	GetLabel                    []gax.CallOption
	GetLabelLimits              []gax.CallOption
	CreateLabel                 []gax.CallOption
	DeltaUpdateLabel            []gax.CallOption
	UpdateLabelCopyMode         []gax.CallOption
	PublishLabel                []gax.CallOption
	DisableLabel                []gax.CallOption
	EnableLabel                 []gax.CallOption
	DeleteLabel                 []gax.CallOption
	ListLabelPermissions        []gax.CallOption
	CreateLabelPermission       []gax.CallOption
	UpdateLabelPermission       []gax.CallOption
	DeleteLabelPermission       []gax.CallOption
	BatchUpdateLabelPermissions []gax.CallOption
	BatchDeleteLabelPermissions []gax.CallOption
	ListLabelLocks              []gax.CallOption
}

func defaultLabelGRPCClientOptions() []option.ClientOption {
	return []option.ClientOption{
		internaloption.WithDefaultEndpoint("drivelabels.googleapis.com:443"),
		internaloption.WithDefaultEndpointTemplate("drivelabels.UNIVERSE_DOMAIN:443"),
		internaloption.WithDefaultMTLSEndpoint("drivelabels.mtls.googleapis.com:443"),
		internaloption.WithDefaultUniverseDomain("googleapis.com"),
		internaloption.WithDefaultAudience("https://drivelabels.googleapis.com/"),
		internaloption.WithDefaultScopes(DefaultAuthScopes()...),
		internaloption.EnableJwtWithScope(),
		internaloption.EnableNewAuthLibrary(),
		option.WithGRPCDialOption(grpc.WithDefaultCallOptions(
			grpc.MaxCallRecvMsgSize(math.MaxInt32))),
	}
}

func defaultLabelCallOptions() *LabelCallOptions {
	return &LabelCallOptions{
		GetUserCapabilities:         []gax.CallOption{},
		ListLabels:                  []gax.CallOption{},
		GetLabel:                    []gax.CallOption{},
		GetLabelLimits:              []gax.CallOption{},
		CreateLabel:                 []gax.CallOption{},
		DeltaUpdateLabel:            []gax.CallOption{},
		UpdateLabelCopyMode:         []gax.CallOption{},
		PublishLabel:                []gax.CallOption{},
		DisableLabel:                []gax.CallOption{},
		EnableLabel:                 []gax.CallOption{},
		DeleteLabel:                 []gax.CallOption{},
		ListLabelPermissions:        []gax.CallOption{},
		CreateLabelPermission:       []gax.CallOption{},
		UpdateLabelPermission:       []gax.CallOption{},
		DeleteLabelPermission:       []gax.CallOption{},
		BatchUpdateLabelPermissions: []gax.CallOption{},
		BatchDeleteLabelPermissions: []gax.CallOption{},
		ListLabelLocks:              []gax.CallOption{},
	}
}

func defaultLabelRESTCallOptions() *LabelCallOptions {
	return &LabelCallOptions{
		GetUserCapabilities:         []gax.CallOption{},
		ListLabels:                  []gax.CallOption{},
		GetLabel:                    []gax.CallOption{},
		GetLabelLimits:              []gax.CallOption{},
		CreateLabel:                 []gax.CallOption{},
		DeltaUpdateLabel:            []gax.CallOption{},
		UpdateLabelCopyMode:         []gax.CallOption{},
		PublishLabel:                []gax.CallOption{},
		DisableLabel:                []gax.CallOption{},
		EnableLabel:                 []gax.CallOption{},
		DeleteLabel:                 []gax.CallOption{},
		ListLabelPermissions:        []gax.CallOption{},
		CreateLabelPermission:       []gax.CallOption{},
		UpdateLabelPermission:       []gax.CallOption{},
		DeleteLabelPermission:       []gax.CallOption{},
		BatchUpdateLabelPermissions: []gax.CallOption{},
		BatchDeleteLabelPermissions: []gax.CallOption{},
		ListLabelLocks:              []gax.CallOption{},
	}
}

// internalLabelClient is an interface that defines the methods available from Drive Labels API.
type internalLabelClient interface {
	Close() error
	setGoogleClientInfo(...string)
	Connection() *grpc.ClientConn
	GetUserCapabilities(context.Context, *labelspb.GetUserCapabilitiesRequest, ...gax.CallOption) (*labelspb.UserCapabilities, error)
	ListLabels(context.Context, *labelspb.ListLabelsRequest, ...gax.CallOption) *LabelIterator
	GetLabel(context.Context, *labelspb.GetLabelRequest, ...gax.CallOption) (*labelspb.Label, error)
	GetLabelLimits(context.Context, *labelspb.GetLabelLimitsRequest, ...gax.CallOption) (*labelspb.LabelLimits, error)
	CreateLabel(context.Context, *labelspb.CreateLabelRequest, ...gax.CallOption) (*labelspb.Label, error)
	DeltaUpdateLabel(context.Context, *labelspb.DeltaUpdateLabelRequest, ...gax.CallOption) (*labelspb.DeltaUpdateLabelResponse, error)
	UpdateLabelCopyMode(context.Context, *labelspb.UpdateLabelCopyModeRequest, ...gax.CallOption) (*labelspb.Label, error)
	PublishLabel(context.Context, *labelspb.PublishLabelRequest, ...gax.CallOption) (*labelspb.Label, error)
	DisableLabel(context.Context, *labelspb.DisableLabelRequest, ...gax.CallOption) (*labelspb.Label, error)
	EnableLabel(context.Context, *labelspb.EnableLabelRequest, ...gax.CallOption) (*labelspb.Label, error)
	DeleteLabel(context.Context, *labelspb.DeleteLabelRequest, ...gax.CallOption) error
	ListLabelPermissions(context.Context, *labelspb.ListLabelPermissionsRequest, ...gax.CallOption) *LabelPermissionIterator
	CreateLabelPermission(context.Context, *labelspb.CreateLabelPermissionRequest, ...gax.CallOption) (*labelspb.LabelPermission, error)
	UpdateLabelPermission(context.Context, *labelspb.UpdateLabelPermissionRequest, ...gax.CallOption) (*labelspb.LabelPermission, error)
	DeleteLabelPermission(context.Context, *labelspb.DeleteLabelPermissionRequest, ...gax.CallOption) error
	BatchUpdateLabelPermissions(context.Context, *labelspb.BatchUpdateLabelPermissionsRequest, ...gax.CallOption) (*labelspb.BatchUpdateLabelPermissionsResponse, error)
	BatchDeleteLabelPermissions(context.Context, *labelspb.BatchDeleteLabelPermissionsRequest, ...gax.CallOption) error
	ListLabelLocks(context.Context, *labelspb.ListLabelLocksRequest, ...gax.CallOption) *LabelLockIterator
}

// LabelClient is a client for interacting with Drive Labels API.
// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
//
// Manage metadata taxonomies based on Labels and Fields that may be used within
// Google Drive to organize and find files using custom metadata.
type LabelClient struct {
	// The internal transport-dependent client.
	internalClient internalLabelClient

	// The call options for this service.
	CallOptions *LabelCallOptions
}

// Wrapper methods routed to the internal client.

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *LabelClient) Close() error {
	return c.internalClient.Close()
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *LabelClient) setGoogleClientInfo(keyval ...string) {
	c.internalClient.setGoogleClientInfo(keyval...)
}

// Connection returns a connection to the API service.
//
// Deprecated: Connections are now pooled so this method does not always
// return the same resource.
func (c *LabelClient) Connection() *grpc.ClientConn {
	return c.internalClient.Connection()
}

// GetUserCapabilities gets the user capabilities.
func (c *LabelClient) GetUserCapabilities(ctx context.Context, req *labelspb.GetUserCapabilitiesRequest, opts ...gax.CallOption) (*labelspb.UserCapabilities, error) {
	return c.internalClient.GetUserCapabilities(ctx, req, opts...)
}

// ListLabels list labels.
func (c *LabelClient) ListLabels(ctx context.Context, req *labelspb.ListLabelsRequest, opts ...gax.CallOption) *LabelIterator {
	return c.internalClient.ListLabels(ctx, req, opts...)
}

// GetLabel get a label by its resource name.
// Resource name may be any of:
//
//	labels/{id} - See labels/{id}@latest
//
//	labels/{id}@latest - Gets the latest revision of the label.
//
//	labels/{id}@published - Gets the current published revision of the
//	label.
//
//	labels/{id}@{revision_id} - Gets the label at the specified revision
//	ID.
func (c *LabelClient) GetLabel(ctx context.Context, req *labelspb.GetLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	return c.internalClient.GetLabel(ctx, req, opts...)
}

// GetLabelLimits get the constraints on the structure of a Label; such as, the maximum
// number of Fields allowed and maximum length of the label title.
func (c *LabelClient) GetLabelLimits(ctx context.Context, req *labelspb.GetLabelLimitsRequest, opts ...gax.CallOption) (*labelspb.LabelLimits, error) {
	return c.internalClient.GetLabelLimits(ctx, req, opts...)
}

// CreateLabel creates a new Label.
func (c *LabelClient) CreateLabel(ctx context.Context, req *labelspb.CreateLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	return c.internalClient.CreateLabel(ctx, req, opts...)
}

// DeltaUpdateLabel updates a single Label by applying a set of update requests resulting in a
// new draft revision. The batch update is all-or-nothing: If any of the
// update requests are invalid, no changes are applied. The resulting draft
// revision must be published before the changes may be used with Drive Items.
func (c *LabelClient) DeltaUpdateLabel(ctx context.Context, req *labelspb.DeltaUpdateLabelRequest, opts ...gax.CallOption) (*labelspb.DeltaUpdateLabelResponse, error) {
	return c.internalClient.DeltaUpdateLabel(ctx, req, opts...)
}

// UpdateLabelCopyMode updates a Label’s CopyMode. Changes to this policy are not revisioned, do
// not require publishing, and take effect immediately.
func (c *LabelClient) UpdateLabelCopyMode(ctx context.Context, req *labelspb.UpdateLabelCopyModeRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	return c.internalClient.UpdateLabelCopyMode(ctx, req, opts...)
}

// PublishLabel publish all draft changes to the Label. Once published, the Label may not
// return to its draft state. See
// google.apps.drive.labels.v2.Lifecycle for more information.
//
// Publishing a Label will result in a new published revision. All previous
// draft revisions will be deleted. Previous published revisions will be kept
// but are subject to automated deletion as needed.
//
// Once published, some changes are no longer permitted. Generally, any change
// that would invalidate or cause new restrictions on existing metadata
// related to the Label will be rejected. For example, the following changes
// to a Label will be rejected after the Label is published:
//
//	The label cannot be directly deleted. It must be disabled first, then
//	deleted.
//
//	Field.FieldType cannot be changed.
//
//	Changes to Field validation options cannot reject something that was
//	previously accepted.
//
//	Reducing the max entries.
func (c *LabelClient) PublishLabel(ctx context.Context, req *labelspb.PublishLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	return c.internalClient.PublishLabel(ctx, req, opts...)
}

// DisableLabel disable a published Label.
// Disabling a Label will result in a new disabled published revision based on
// the current published revision. If there is a draft revision, a new
// disabled draft revision will be created based on the latest draft revision.
// Older draft revisions will be deleted.
//
// Once disabled, a label may be deleted with DeleteLabel.
func (c *LabelClient) DisableLabel(ctx context.Context, req *labelspb.DisableLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	return c.internalClient.DisableLabel(ctx, req, opts...)
}

// EnableLabel enable a disabled Label and restore it to its published state.
// This will result in a new published revision based on the current disabled
// published revision. If there is an existing disabled draft revision, a new
// revision will be created based on that draft and will be enabled.
func (c *LabelClient) EnableLabel(ctx context.Context, req *labelspb.EnableLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	return c.internalClient.EnableLabel(ctx, req, opts...)
}

// DeleteLabel permanently deletes a Label and related metadata on Drive Items.
//
// Once deleted, the Label and related Drive item metadata will be deleted.
// Only draft Labels, and disabled Labels may be deleted.
func (c *LabelClient) DeleteLabel(ctx context.Context, req *labelspb.DeleteLabelRequest, opts ...gax.CallOption) error {
	return c.internalClient.DeleteLabel(ctx, req, opts...)
}

// ListLabelPermissions lists a Label’s permissions.
func (c *LabelClient) ListLabelPermissions(ctx context.Context, req *labelspb.ListLabelPermissionsRequest, opts ...gax.CallOption) *LabelPermissionIterator {
	return c.internalClient.ListLabelPermissions(ctx, req, opts...)
}

// CreateLabelPermission updates a Label’s permissions. If a permission for the indicated principal
// doesn’t exist, a new Label Permission is created, otherwise the existing
// permission is updated. Permissions affect the Label resource as a whole,
// are not revisioned, and do not require publishing.
func (c *LabelClient) CreateLabelPermission(ctx context.Context, req *labelspb.CreateLabelPermissionRequest, opts ...gax.CallOption) (*labelspb.LabelPermission, error) {
	return c.internalClient.CreateLabelPermission(ctx, req, opts...)
}

// UpdateLabelPermission updates a Label’s permissions. If a permission for the indicated principal
// doesn’t exist, a new Label Permission is created, otherwise the existing
// permission is updated. Permissions affect the Label resource as a whole,
// are not revisioned, and do not require publishing.
func (c *LabelClient) UpdateLabelPermission(ctx context.Context, req *labelspb.UpdateLabelPermissionRequest, opts ...gax.CallOption) (*labelspb.LabelPermission, error) {
	return c.internalClient.UpdateLabelPermission(ctx, req, opts...)
}

// DeleteLabelPermission deletes a Label’s permission. Permissions affect the Label resource as a
// whole, are not revisioned, and do not require publishing.
func (c *LabelClient) DeleteLabelPermission(ctx context.Context, req *labelspb.DeleteLabelPermissionRequest, opts ...gax.CallOption) error {
	return c.internalClient.DeleteLabelPermission(ctx, req, opts...)
}

// BatchUpdateLabelPermissions updates Label permissions. If a permission for the
// indicated principal doesn’t exist, a new Label Permission is created,
// otherwise the existing permission is updated. Permissions affect the Label
// resource as a whole, are not revisioned, and do not require publishing.
func (c *LabelClient) BatchUpdateLabelPermissions(ctx context.Context, req *labelspb.BatchUpdateLabelPermissionsRequest, opts ...gax.CallOption) (*labelspb.BatchUpdateLabelPermissionsResponse, error) {
	return c.internalClient.BatchUpdateLabelPermissions(ctx, req, opts...)
}

// BatchDeleteLabelPermissions deletes Label permissions. Permissions affect the Label resource as a
// whole, are not revisioned, and do not require publishing.
func (c *LabelClient) BatchDeleteLabelPermissions(ctx context.Context, req *labelspb.BatchDeleteLabelPermissionsRequest, opts ...gax.CallOption) error {
	return c.internalClient.BatchDeleteLabelPermissions(ctx, req, opts...)
}

// ListLabelLocks lists the LabelLocks on a Label.
func (c *LabelClient) ListLabelLocks(ctx context.Context, req *labelspb.ListLabelLocksRequest, opts ...gax.CallOption) *LabelLockIterator {
	return c.internalClient.ListLabelLocks(ctx, req, opts...)
}

// labelGRPCClient is a client for interacting with Drive Labels API over gRPC transport.
//
// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
type labelGRPCClient struct {
	// Connection pool of gRPC connections to the service.
	connPool gtransport.ConnPool

	// Points back to the CallOptions field of the containing LabelClient
	CallOptions **LabelCallOptions

	// The gRPC API client.
	labelClient labelspb.LabelServiceClient

	// The x-goog-* metadata to be sent with each request.
	xGoogHeaders []string
}

// NewLabelClient creates a new label service client based on gRPC.
// The returned client must be Closed when it is done being used to clean up its underlying connections.
//
// Manage metadata taxonomies based on Labels and Fields that may be used within
// Google Drive to organize and find files using custom metadata.
func NewLabelClient(ctx context.Context, opts ...option.ClientOption) (*LabelClient, error) {
	clientOpts := defaultLabelGRPCClientOptions()
	if newLabelClientHook != nil {
		hookOpts, err := newLabelClientHook(ctx, clientHookParams{})
		if err != nil {
			return nil, err
		}
		clientOpts = append(clientOpts, hookOpts...)
	}

	connPool, err := gtransport.DialPool(ctx, append(clientOpts, opts...)...)
	if err != nil {
		return nil, err
	}
	client := LabelClient{CallOptions: defaultLabelCallOptions()}

	c := &labelGRPCClient{
		connPool:    connPool,
		labelClient: labelspb.NewLabelServiceClient(connPool),
		CallOptions: &client.CallOptions,
	}
	c.setGoogleClientInfo()

	client.internalClient = c

	return &client, nil
}

// Connection returns a connection to the API service.
//
// Deprecated: Connections are now pooled so this method does not always
// return the same resource.
func (c *labelGRPCClient) Connection() *grpc.ClientConn {
	return c.connPool.Conn()
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *labelGRPCClient) setGoogleClientInfo(keyval ...string) {
	kv := append([]string{"gl-go", gax.GoVersion}, keyval...)
	kv = append(kv, "gapic", getVersionClient(), "gax", gax.Version, "grpc", grpc.Version)
	c.xGoogHeaders = []string{
		"x-goog-api-client", gax.XGoogHeader(kv...),
	}
}

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *labelGRPCClient) Close() error {
	return c.connPool.Close()
}

// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
type labelRESTClient struct {
	// The http endpoint to connect to.
	endpoint string

	// The http client.
	httpClient *http.Client

	// The x-goog-* headers to be sent with each request.
	xGoogHeaders []string

	// Points back to the CallOptions field of the containing LabelClient
	CallOptions **LabelCallOptions
}

// NewLabelRESTClient creates a new label service rest client.
//
// Manage metadata taxonomies based on Labels and Fields that may be used within
// Google Drive to organize and find files using custom metadata.
func NewLabelRESTClient(ctx context.Context, opts ...option.ClientOption) (*LabelClient, error) {
	clientOpts := append(defaultLabelRESTClientOptions(), opts...)
	httpClient, endpoint, err := httptransport.NewClient(ctx, clientOpts...)
	if err != nil {
		return nil, err
	}

	callOpts := defaultLabelRESTCallOptions()
	c := &labelRESTClient{
		endpoint:    endpoint,
		httpClient:  httpClient,
		CallOptions: &callOpts,
	}
	c.setGoogleClientInfo()

	return &LabelClient{internalClient: c, CallOptions: callOpts}, nil
}

func defaultLabelRESTClientOptions() []option.ClientOption {
	return []option.ClientOption{
		internaloption.WithDefaultEndpoint("https://drivelabels.googleapis.com"),
		internaloption.WithDefaultEndpointTemplate("https://drivelabels.UNIVERSE_DOMAIN"),
		internaloption.WithDefaultMTLSEndpoint("https://drivelabels.mtls.googleapis.com"),
		internaloption.WithDefaultUniverseDomain("googleapis.com"),
		internaloption.WithDefaultAudience("https://drivelabels.googleapis.com/"),
		internaloption.WithDefaultScopes(DefaultAuthScopes()...),
		internaloption.EnableNewAuthLibrary(),
	}
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *labelRESTClient) setGoogleClientInfo(keyval ...string) {
	kv := append([]string{"gl-go", gax.GoVersion}, keyval...)
	kv = append(kv, "gapic", getVersionClient(), "gax", gax.Version, "rest", "UNKNOWN")
	c.xGoogHeaders = []string{
		"x-goog-api-client", gax.XGoogHeader(kv...),
	}
}

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *labelRESTClient) Close() error {
	// Replace httpClient with nil to force cleanup.
	c.httpClient = nil
	return nil
}

// Connection returns a connection to the API service.
//
// Deprecated: This method always returns nil.
func (c *labelRESTClient) Connection() *grpc.ClientConn {
	return nil
}
func (c *labelGRPCClient) GetUserCapabilities(ctx context.Context, req *labelspb.GetUserCapabilitiesRequest, opts ...gax.CallOption) (*labelspb.UserCapabilities, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetUserCapabilities[0:len((*c.CallOptions).GetUserCapabilities):len((*c.CallOptions).GetUserCapabilities)], opts...)
	var resp *labelspb.UserCapabilities
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.GetUserCapabilities(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) ListLabels(ctx context.Context, req *labelspb.ListLabelsRequest, opts ...gax.CallOption) *LabelIterator {
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, c.xGoogHeaders...)
	opts = append((*c.CallOptions).ListLabels[0:len((*c.CallOptions).ListLabels):len((*c.CallOptions).ListLabels)], opts...)
	it := &LabelIterator{}
	req = proto.Clone(req).(*labelspb.ListLabelsRequest)
	it.InternalFetch = func(pageSize int, pageToken string) ([]*labelspb.Label, string, error) {
		resp := &labelspb.ListLabelsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			var err error
			resp, err = c.labelClient.ListLabels(ctx, req, settings.GRPC...)
			return err
		}, opts...)
		if err != nil {
			return nil, "", err
		}

		it.Response = resp
		return resp.GetLabels(), resp.GetNextPageToken(), nil
	}
	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

func (c *labelGRPCClient) GetLabel(ctx context.Context, req *labelspb.GetLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetLabel[0:len((*c.CallOptions).GetLabel):len((*c.CallOptions).GetLabel)], opts...)
	var resp *labelspb.Label
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.GetLabel(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) GetLabelLimits(ctx context.Context, req *labelspb.GetLabelLimitsRequest, opts ...gax.CallOption) (*labelspb.LabelLimits, error) {
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, c.xGoogHeaders...)
	opts = append((*c.CallOptions).GetLabelLimits[0:len((*c.CallOptions).GetLabelLimits):len((*c.CallOptions).GetLabelLimits)], opts...)
	var resp *labelspb.LabelLimits
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.GetLabelLimits(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) CreateLabel(ctx context.Context, req *labelspb.CreateLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, c.xGoogHeaders...)
	opts = append((*c.CallOptions).CreateLabel[0:len((*c.CallOptions).CreateLabel):len((*c.CallOptions).CreateLabel)], opts...)
	var resp *labelspb.Label
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.CreateLabel(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) DeltaUpdateLabel(ctx context.Context, req *labelspb.DeltaUpdateLabelRequest, opts ...gax.CallOption) (*labelspb.DeltaUpdateLabelResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeltaUpdateLabel[0:len((*c.CallOptions).DeltaUpdateLabel):len((*c.CallOptions).DeltaUpdateLabel)], opts...)
	var resp *labelspb.DeltaUpdateLabelResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.DeltaUpdateLabel(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) UpdateLabelCopyMode(ctx context.Context, req *labelspb.UpdateLabelCopyModeRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).UpdateLabelCopyMode[0:len((*c.CallOptions).UpdateLabelCopyMode):len((*c.CallOptions).UpdateLabelCopyMode)], opts...)
	var resp *labelspb.Label
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.UpdateLabelCopyMode(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) PublishLabel(ctx context.Context, req *labelspb.PublishLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).PublishLabel[0:len((*c.CallOptions).PublishLabel):len((*c.CallOptions).PublishLabel)], opts...)
	var resp *labelspb.Label
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.PublishLabel(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) DisableLabel(ctx context.Context, req *labelspb.DisableLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DisableLabel[0:len((*c.CallOptions).DisableLabel):len((*c.CallOptions).DisableLabel)], opts...)
	var resp *labelspb.Label
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.DisableLabel(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) EnableLabel(ctx context.Context, req *labelspb.EnableLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).EnableLabel[0:len((*c.CallOptions).EnableLabel):len((*c.CallOptions).EnableLabel)], opts...)
	var resp *labelspb.Label
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.EnableLabel(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) DeleteLabel(ctx context.Context, req *labelspb.DeleteLabelRequest, opts ...gax.CallOption) error {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeleteLabel[0:len((*c.CallOptions).DeleteLabel):len((*c.CallOptions).DeleteLabel)], opts...)
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		_, err = c.labelClient.DeleteLabel(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	return err
}

func (c *labelGRPCClient) ListLabelPermissions(ctx context.Context, req *labelspb.ListLabelPermissionsRequest, opts ...gax.CallOption) *LabelPermissionIterator {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListLabelPermissions[0:len((*c.CallOptions).ListLabelPermissions):len((*c.CallOptions).ListLabelPermissions)], opts...)
	it := &LabelPermissionIterator{}
	req = proto.Clone(req).(*labelspb.ListLabelPermissionsRequest)
	it.InternalFetch = func(pageSize int, pageToken string) ([]*labelspb.LabelPermission, string, error) {
		resp := &labelspb.ListLabelPermissionsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			var err error
			resp, err = c.labelClient.ListLabelPermissions(ctx, req, settings.GRPC...)
			return err
		}, opts...)
		if err != nil {
			return nil, "", err
		}

		it.Response = resp
		return resp.GetLabelPermissions(), resp.GetNextPageToken(), nil
	}
	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

func (c *labelGRPCClient) CreateLabelPermission(ctx context.Context, req *labelspb.CreateLabelPermissionRequest, opts ...gax.CallOption) (*labelspb.LabelPermission, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).CreateLabelPermission[0:len((*c.CallOptions).CreateLabelPermission):len((*c.CallOptions).CreateLabelPermission)], opts...)
	var resp *labelspb.LabelPermission
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.CreateLabelPermission(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) UpdateLabelPermission(ctx context.Context, req *labelspb.UpdateLabelPermissionRequest, opts ...gax.CallOption) (*labelspb.LabelPermission, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).UpdateLabelPermission[0:len((*c.CallOptions).UpdateLabelPermission):len((*c.CallOptions).UpdateLabelPermission)], opts...)
	var resp *labelspb.LabelPermission
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.UpdateLabelPermission(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) DeleteLabelPermission(ctx context.Context, req *labelspb.DeleteLabelPermissionRequest, opts ...gax.CallOption) error {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeleteLabelPermission[0:len((*c.CallOptions).DeleteLabelPermission):len((*c.CallOptions).DeleteLabelPermission)], opts...)
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		_, err = c.labelClient.DeleteLabelPermission(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	return err
}

func (c *labelGRPCClient) BatchUpdateLabelPermissions(ctx context.Context, req *labelspb.BatchUpdateLabelPermissionsRequest, opts ...gax.CallOption) (*labelspb.BatchUpdateLabelPermissionsResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).BatchUpdateLabelPermissions[0:len((*c.CallOptions).BatchUpdateLabelPermissions):len((*c.CallOptions).BatchUpdateLabelPermissions)], opts...)
	var resp *labelspb.BatchUpdateLabelPermissionsResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.labelClient.BatchUpdateLabelPermissions(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *labelGRPCClient) BatchDeleteLabelPermissions(ctx context.Context, req *labelspb.BatchDeleteLabelPermissionsRequest, opts ...gax.CallOption) error {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).BatchDeleteLabelPermissions[0:len((*c.CallOptions).BatchDeleteLabelPermissions):len((*c.CallOptions).BatchDeleteLabelPermissions)], opts...)
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		_, err = c.labelClient.BatchDeleteLabelPermissions(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	return err
}

func (c *labelGRPCClient) ListLabelLocks(ctx context.Context, req *labelspb.ListLabelLocksRequest, opts ...gax.CallOption) *LabelLockIterator {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListLabelLocks[0:len((*c.CallOptions).ListLabelLocks):len((*c.CallOptions).ListLabelLocks)], opts...)
	it := &LabelLockIterator{}
	req = proto.Clone(req).(*labelspb.ListLabelLocksRequest)
	it.InternalFetch = func(pageSize int, pageToken string) ([]*labelspb.LabelLock, string, error) {
		resp := &labelspb.ListLabelLocksResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			var err error
			resp, err = c.labelClient.ListLabelLocks(ctx, req, settings.GRPC...)
			return err
		}, opts...)
		if err != nil {
			return nil, "", err
		}

		it.Response = resp
		return resp.GetLabelLocks(), resp.GetNextPageToken(), nil
	}
	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

// GetUserCapabilities gets the user capabilities.
func (c *labelRESTClient) GetUserCapabilities(ctx context.Context, req *labelspb.GetUserCapabilitiesRequest, opts ...gax.CallOption) (*labelspb.UserCapabilities, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req.GetCustomer() != "" {
		params.Add("customer", fmt.Sprintf("%v", req.GetCustomer()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetUserCapabilities[0:len((*c.CallOptions).GetUserCapabilities):len((*c.CallOptions).GetUserCapabilities)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.UserCapabilities{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListLabels list labels.
func (c *labelRESTClient) ListLabels(ctx context.Context, req *labelspb.ListLabelsRequest, opts ...gax.CallOption) *LabelIterator {
	it := &LabelIterator{}
	req = proto.Clone(req).(*labelspb.ListLabelsRequest)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	it.InternalFetch = func(pageSize int, pageToken string) ([]*labelspb.Label, string, error) {
		resp := &labelspb.ListLabelsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		baseUrl, err := url.Parse(c.endpoint)
		if err != nil {
			return nil, "", err
		}
		baseUrl.Path += fmt.Sprintf("/v2beta/labels")

		params := url.Values{}
		params.Add("$alt", "json;enum-encoding=int")
		if req.GetCustomer() != "" {
			params.Add("customer", fmt.Sprintf("%v", req.GetCustomer()))
		}
		if req.GetLanguageCode() != "" {
			params.Add("languageCode", fmt.Sprintf("%v", req.GetLanguageCode()))
		}
		if req.GetMinimumRole() != 0 {
			params.Add("minimumRole", fmt.Sprintf("%v", req.GetMinimumRole()))
		}
		if req.GetPageSize() != 0 {
			params.Add("pageSize", fmt.Sprintf("%v", req.GetPageSize()))
		}
		if req.GetPageToken() != "" {
			params.Add("pageToken", fmt.Sprintf("%v", req.GetPageToken()))
		}
		if req.GetPublishedOnly() {
			params.Add("publishedOnly", fmt.Sprintf("%v", req.GetPublishedOnly()))
		}
		if req.GetUseAdminAccess() {
			params.Add("useAdminAccess", fmt.Sprintf("%v", req.GetUseAdminAccess()))
		}
		if req.GetView() != 0 {
			params.Add("view", fmt.Sprintf("%v", req.GetView()))
		}

		baseUrl.RawQuery = params.Encode()

		// Build HTTP headers from client and context metadata.
		hds := append(c.xGoogHeaders, "Content-Type", "application/json")
		headers := gax.BuildHeaders(ctx, hds...)
		e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			if settings.Path != "" {
				baseUrl.Path = settings.Path
			}
			httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
			if err != nil {
				return err
			}
			httpReq.Header = headers

			httpRsp, err := c.httpClient.Do(httpReq)
			if err != nil {
				return err
			}
			defer httpRsp.Body.Close()

			if err = googleapi.CheckResponse(httpRsp); err != nil {
				return err
			}

			buf, err := io.ReadAll(httpRsp.Body)
			if err != nil {
				return err
			}

			if err := unm.Unmarshal(buf, resp); err != nil {
				return err
			}

			return nil
		}, opts...)
		if e != nil {
			return nil, "", e
		}
		it.Response = resp
		return resp.GetLabels(), resp.GetNextPageToken(), nil
	}

	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

// GetLabel get a label by its resource name.
// Resource name may be any of:
//
//	labels/{id} - See labels/{id}@latest
//
//	labels/{id}@latest - Gets the latest revision of the label.
//
//	labels/{id}@published - Gets the current published revision of the
//	label.
//
//	labels/{id}@{revision_id} - Gets the label at the specified revision
//	ID.
func (c *labelRESTClient) GetLabel(ctx context.Context, req *labelspb.GetLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req.GetLanguageCode() != "" {
		params.Add("languageCode", fmt.Sprintf("%v", req.GetLanguageCode()))
	}
	if req.GetUseAdminAccess() {
		params.Add("useAdminAccess", fmt.Sprintf("%v", req.GetUseAdminAccess()))
	}
	if req.GetView() != 0 {
		params.Add("view", fmt.Sprintf("%v", req.GetView()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetLabel[0:len((*c.CallOptions).GetLabel):len((*c.CallOptions).GetLabel)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.Label{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetLabelLimits get the constraints on the structure of a Label; such as, the maximum
// number of Fields allowed and maximum length of the label title.
func (c *labelRESTClient) GetLabelLimits(ctx context.Context, req *labelspb.GetLabelLimitsRequest, opts ...gax.CallOption) (*labelspb.LabelLimits, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/limits/label")

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	params.Add("name", fmt.Sprintf("%v", req.GetName()))

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := append(c.xGoogHeaders, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetLabelLimits[0:len((*c.CallOptions).GetLabelLimits):len((*c.CallOptions).GetLabelLimits)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.LabelLimits{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// CreateLabel creates a new Label.
func (c *labelRESTClient) CreateLabel(ctx context.Context, req *labelspb.CreateLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	body := req.GetLabel()
	jsonReq, err := m.Marshal(body)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/labels")

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req.GetLanguageCode() != "" {
		params.Add("languageCode", fmt.Sprintf("%v", req.GetLanguageCode()))
	}
	if req.GetUseAdminAccess() {
		params.Add("useAdminAccess", fmt.Sprintf("%v", req.GetUseAdminAccess()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := append(c.xGoogHeaders, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).CreateLabel[0:len((*c.CallOptions).CreateLabel):len((*c.CallOptions).CreateLabel)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.Label{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DeltaUpdateLabel updates a single Label by applying a set of update requests resulting in a
// new draft revision. The batch update is all-or-nothing: If any of the
// update requests are invalid, no changes are applied. The resulting draft
// revision must be published before the changes may be used with Drive Items.
func (c *labelRESTClient) DeltaUpdateLabel(ctx context.Context, req *labelspb.DeltaUpdateLabelRequest, opts ...gax.CallOption) (*labelspb.DeltaUpdateLabelResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v:delta", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).DeltaUpdateLabel[0:len((*c.CallOptions).DeltaUpdateLabel):len((*c.CallOptions).DeltaUpdateLabel)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.DeltaUpdateLabelResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// UpdateLabelCopyMode updates a Label’s CopyMode. Changes to this policy are not revisioned, do
// not require publishing, and take effect immediately.
func (c *labelRESTClient) UpdateLabelCopyMode(ctx context.Context, req *labelspb.UpdateLabelCopyModeRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v:updateLabelCopyMode", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).UpdateLabelCopyMode[0:len((*c.CallOptions).UpdateLabelCopyMode):len((*c.CallOptions).UpdateLabelCopyMode)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.Label{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// PublishLabel publish all draft changes to the Label. Once published, the Label may not
// return to its draft state. See
// google.apps.drive.labels.v2.Lifecycle for more information.
//
// Publishing a Label will result in a new published revision. All previous
// draft revisions will be deleted. Previous published revisions will be kept
// but are subject to automated deletion as needed.
//
// Once published, some changes are no longer permitted. Generally, any change
// that would invalidate or cause new restrictions on existing metadata
// related to the Label will be rejected. For example, the following changes
// to a Label will be rejected after the Label is published:
//
//	The label cannot be directly deleted. It must be disabled first, then
//	deleted.
//
//	Field.FieldType cannot be changed.
//
//	Changes to Field validation options cannot reject something that was
//	previously accepted.
//
//	Reducing the max entries.
func (c *labelRESTClient) PublishLabel(ctx context.Context, req *labelspb.PublishLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v:publish", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).PublishLabel[0:len((*c.CallOptions).PublishLabel):len((*c.CallOptions).PublishLabel)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.Label{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DisableLabel disable a published Label.
// Disabling a Label will result in a new disabled published revision based on
// the current published revision. If there is a draft revision, a new
// disabled draft revision will be created based on the latest draft revision.
// Older draft revisions will be deleted.
//
// Once disabled, a label may be deleted with DeleteLabel.
func (c *labelRESTClient) DisableLabel(ctx context.Context, req *labelspb.DisableLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v:disable", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).DisableLabel[0:len((*c.CallOptions).DisableLabel):len((*c.CallOptions).DisableLabel)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.Label{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// EnableLabel enable a disabled Label and restore it to its published state.
// This will result in a new published revision based on the current disabled
// published revision. If there is an existing disabled draft revision, a new
// revision will be created based on that draft and will be enabled.
func (c *labelRESTClient) EnableLabel(ctx context.Context, req *labelspb.EnableLabelRequest, opts ...gax.CallOption) (*labelspb.Label, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v:enable", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).EnableLabel[0:len((*c.CallOptions).EnableLabel):len((*c.CallOptions).EnableLabel)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.Label{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DeleteLabel permanently deletes a Label and related metadata on Drive Items.
//
// Once deleted, the Label and related Drive item metadata will be deleted.
// Only draft Labels, and disabled Labels may be deleted.
func (c *labelRESTClient) DeleteLabel(ctx context.Context, req *labelspb.DeleteLabelRequest, opts ...gax.CallOption) error {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req.GetUseAdminAccess() {
		params.Add("useAdminAccess", fmt.Sprintf("%v", req.GetUseAdminAccess()))
	}
	if req.GetWriteControl().GetRequiredRevisionId() != "" {
		params.Add("writeControl.requiredRevisionId", fmt.Sprintf("%v", req.GetWriteControl().GetRequiredRevisionId()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	return gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("DELETE", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		// Returns nil if there is no error, otherwise wraps
		// the response code and body into a non-nil error
		return googleapi.CheckResponse(httpRsp)
	}, opts...)
}

// ListLabelPermissions lists a Label’s permissions.
func (c *labelRESTClient) ListLabelPermissions(ctx context.Context, req *labelspb.ListLabelPermissionsRequest, opts ...gax.CallOption) *LabelPermissionIterator {
	it := &LabelPermissionIterator{}
	req = proto.Clone(req).(*labelspb.ListLabelPermissionsRequest)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	it.InternalFetch = func(pageSize int, pageToken string) ([]*labelspb.LabelPermission, string, error) {
		resp := &labelspb.ListLabelPermissionsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		baseUrl, err := url.Parse(c.endpoint)
		if err != nil {
			return nil, "", err
		}
		baseUrl.Path += fmt.Sprintf("/v2beta/%v/permissions", req.GetParent())

		params := url.Values{}
		params.Add("$alt", "json;enum-encoding=int")
		if req.GetPageSize() != 0 {
			params.Add("pageSize", fmt.Sprintf("%v", req.GetPageSize()))
		}
		if req.GetPageToken() != "" {
			params.Add("pageToken", fmt.Sprintf("%v", req.GetPageToken()))
		}
		if req.GetUseAdminAccess() {
			params.Add("useAdminAccess", fmt.Sprintf("%v", req.GetUseAdminAccess()))
		}

		baseUrl.RawQuery = params.Encode()

		// Build HTTP headers from client and context metadata.
		hds := append(c.xGoogHeaders, "Content-Type", "application/json")
		headers := gax.BuildHeaders(ctx, hds...)
		e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			if settings.Path != "" {
				baseUrl.Path = settings.Path
			}
			httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
			if err != nil {
				return err
			}
			httpReq.Header = headers

			httpRsp, err := c.httpClient.Do(httpReq)
			if err != nil {
				return err
			}
			defer httpRsp.Body.Close()

			if err = googleapi.CheckResponse(httpRsp); err != nil {
				return err
			}

			buf, err := io.ReadAll(httpRsp.Body)
			if err != nil {
				return err
			}

			if err := unm.Unmarshal(buf, resp); err != nil {
				return err
			}

			return nil
		}, opts...)
		if e != nil {
			return nil, "", e
		}
		it.Response = resp
		return resp.GetLabelPermissions(), resp.GetNextPageToken(), nil
	}

	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

// CreateLabelPermission updates a Label’s permissions. If a permission for the indicated principal
// doesn’t exist, a new Label Permission is created, otherwise the existing
// permission is updated. Permissions affect the Label resource as a whole,
// are not revisioned, and do not require publishing.
func (c *labelRESTClient) CreateLabelPermission(ctx context.Context, req *labelspb.CreateLabelPermissionRequest, opts ...gax.CallOption) (*labelspb.LabelPermission, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	body := req.GetLabelPermission()
	jsonReq, err := m.Marshal(body)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v/permissions", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req.GetUseAdminAccess() {
		params.Add("useAdminAccess", fmt.Sprintf("%v", req.GetUseAdminAccess()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).CreateLabelPermission[0:len((*c.CallOptions).CreateLabelPermission):len((*c.CallOptions).CreateLabelPermission)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.LabelPermission{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// UpdateLabelPermission updates a Label’s permissions. If a permission for the indicated principal
// doesn’t exist, a new Label Permission is created, otherwise the existing
// permission is updated. Permissions affect the Label resource as a whole,
// are not revisioned, and do not require publishing.
func (c *labelRESTClient) UpdateLabelPermission(ctx context.Context, req *labelspb.UpdateLabelPermissionRequest, opts ...gax.CallOption) (*labelspb.LabelPermission, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	body := req.GetLabelPermission()
	jsonReq, err := m.Marshal(body)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v/permissions", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req.GetUseAdminAccess() {
		params.Add("useAdminAccess", fmt.Sprintf("%v", req.GetUseAdminAccess()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).UpdateLabelPermission[0:len((*c.CallOptions).UpdateLabelPermission):len((*c.CallOptions).UpdateLabelPermission)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.LabelPermission{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("PATCH", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DeleteLabelPermission deletes a Label’s permission. Permissions affect the Label resource as a
// whole, are not revisioned, and do not require publishing.
func (c *labelRESTClient) DeleteLabelPermission(ctx context.Context, req *labelspb.DeleteLabelPermissionRequest, opts ...gax.CallOption) error {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req.GetUseAdminAccess() {
		params.Add("useAdminAccess", fmt.Sprintf("%v", req.GetUseAdminAccess()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	return gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("DELETE", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		// Returns nil if there is no error, otherwise wraps
		// the response code and body into a non-nil error
		return googleapi.CheckResponse(httpRsp)
	}, opts...)
}

// BatchUpdateLabelPermissions updates Label permissions. If a permission for the
// indicated principal doesn’t exist, a new Label Permission is created,
// otherwise the existing permission is updated. Permissions affect the Label
// resource as a whole, are not revisioned, and do not require publishing.
func (c *labelRESTClient) BatchUpdateLabelPermissions(ctx context.Context, req *labelspb.BatchUpdateLabelPermissionsRequest, opts ...gax.CallOption) (*labelspb.BatchUpdateLabelPermissionsResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v/permissions:batchUpdate", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).BatchUpdateLabelPermissions[0:len((*c.CallOptions).BatchUpdateLabelPermissions):len((*c.CallOptions).BatchUpdateLabelPermissions)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &labelspb.BatchUpdateLabelPermissionsResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// BatchDeleteLabelPermissions deletes Label permissions. Permissions affect the Label resource as a
// whole, are not revisioned, and do not require publishing.
func (c *labelRESTClient) BatchDeleteLabelPermissions(ctx context.Context, req *labelspb.BatchDeleteLabelPermissionsRequest, opts ...gax.CallOption) error {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return err
	}
	baseUrl.Path += fmt.Sprintf("/v2beta/%v/permissions:batchDelete", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	return gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		// Returns nil if there is no error, otherwise wraps
		// the response code and body into a non-nil error
		return googleapi.CheckResponse(httpRsp)
	}, opts...)
}

// ListLabelLocks lists the LabelLocks on a Label.
func (c *labelRESTClient) ListLabelLocks(ctx context.Context, req *labelspb.ListLabelLocksRequest, opts ...gax.CallOption) *LabelLockIterator {
	it := &LabelLockIterator{}
	req = proto.Clone(req).(*labelspb.ListLabelLocksRequest)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	it.InternalFetch = func(pageSize int, pageToken string) ([]*labelspb.LabelLock, string, error) {
		resp := &labelspb.ListLabelLocksResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		baseUrl, err := url.Parse(c.endpoint)
		if err != nil {
			return nil, "", err
		}
		baseUrl.Path += fmt.Sprintf("/v2beta/%v/locks", req.GetParent())

		params := url.Values{}
		params.Add("$alt", "json;enum-encoding=int")
		if req.GetPageSize() != 0 {
			params.Add("pageSize", fmt.Sprintf("%v", req.GetPageSize()))
		}
		if req.GetPageToken() != "" {
			params.Add("pageToken", fmt.Sprintf("%v", req.GetPageToken()))
		}

		baseUrl.RawQuery = params.Encode()

		// Build HTTP headers from client and context metadata.
		hds := append(c.xGoogHeaders, "Content-Type", "application/json")
		headers := gax.BuildHeaders(ctx, hds...)
		e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			if settings.Path != "" {
				baseUrl.Path = settings.Path
			}
			httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
			if err != nil {
				return err
			}
			httpReq.Header = headers

			httpRsp, err := c.httpClient.Do(httpReq)
			if err != nil {
				return err
			}
			defer httpRsp.Body.Close()

			if err = googleapi.CheckResponse(httpRsp); err != nil {
				return err
			}

			buf, err := io.ReadAll(httpRsp.Body)
			if err != nil {
				return err
			}

			if err := unm.Unmarshal(buf, resp); err != nil {
				return err
			}

			return nil
		}, opts...)
		if e != nil {
			return nil, "", e
		}
		it.Response = resp
		return resp.GetLabelLocks(), resp.GetNextPageToken(), nil
	}

	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}
