// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go_gapic. DO NOT EDIT.

package data

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net/http"
	"net/url"
	"time"

	"cloud.google.com/go/longrunning"
	lroauto "cloud.google.com/go/longrunning/autogen"
	longrunningpb "cloud.google.com/go/longrunning/autogen/longrunningpb"
	gax "github.com/googleapis/gax-go/v2"
	"google.golang.org/api/googleapi"
	"google.golang.org/api/iterator"
	"google.golang.org/api/option"
	"google.golang.org/api/option/internaloption"
	gtransport "google.golang.org/api/transport/grpc"
	httptransport "google.golang.org/api/transport/http"
	datapb "google.golang.org/genproto/googleapis/analytics/data/v1beta"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

var newBetaAnalyticsDataClientHook clientHook

// BetaAnalyticsDataCallOptions contains the retry settings for each method of BetaAnalyticsDataClient.
type BetaAnalyticsDataCallOptions struct {
	RunReport            []gax.CallOption
	RunPivotReport       []gax.CallOption
	BatchRunReports      []gax.CallOption
	BatchRunPivotReports []gax.CallOption
	GetMetadata          []gax.CallOption
	RunRealtimeReport    []gax.CallOption
	CheckCompatibility   []gax.CallOption
	CreateAudienceExport []gax.CallOption
	QueryAudienceExport  []gax.CallOption
	GetAudienceExport    []gax.CallOption
	ListAudienceExports  []gax.CallOption
}

func defaultBetaAnalyticsDataGRPCClientOptions() []option.ClientOption {
	return []option.ClientOption{
		internaloption.WithDefaultEndpoint("analyticsdata.googleapis.com:443"),
		internaloption.WithDefaultEndpointTemplate("analyticsdata.UNIVERSE_DOMAIN:443"),
		internaloption.WithDefaultMTLSEndpoint("analyticsdata.mtls.googleapis.com:443"),
		internaloption.WithDefaultUniverseDomain("googleapis.com"),
		internaloption.WithDefaultAudience("https://analyticsdata.googleapis.com/"),
		internaloption.WithDefaultScopes(DefaultAuthScopes()...),
		internaloption.EnableJwtWithScope(),
		internaloption.EnableNewAuthLibrary(),
		option.WithGRPCDialOption(grpc.WithDefaultCallOptions(
			grpc.MaxCallRecvMsgSize(math.MaxInt32))),
	}
}

func defaultBetaAnalyticsDataCallOptions() *BetaAnalyticsDataCallOptions {
	return &BetaAnalyticsDataCallOptions{
		RunReport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		RunPivotReport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		BatchRunReports: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		BatchRunPivotReports: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		GetMetadata: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		RunRealtimeReport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		CheckCompatibility: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		CreateAudienceExport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
			gax.WithRetry(func() gax.Retryer {
				return gax.OnCodes([]codes.Code{
					codes.Unknown,
				}, gax.Backoff{
					Initial:    1000 * time.Millisecond,
					Max:        60000 * time.Millisecond,
					Multiplier: 1.30,
				})
			}),
		},
		QueryAudienceExport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
			gax.WithRetry(func() gax.Retryer {
				return gax.OnCodes([]codes.Code{
					codes.Unknown,
				}, gax.Backoff{
					Initial:    1000 * time.Millisecond,
					Max:        60000 * time.Millisecond,
					Multiplier: 1.30,
				})
			}),
		},
		GetAudienceExport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
			gax.WithRetry(func() gax.Retryer {
				return gax.OnCodes([]codes.Code{
					codes.Unknown,
				}, gax.Backoff{
					Initial:    1000 * time.Millisecond,
					Max:        60000 * time.Millisecond,
					Multiplier: 1.30,
				})
			}),
		},
		ListAudienceExports: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
			gax.WithRetry(func() gax.Retryer {
				return gax.OnCodes([]codes.Code{
					codes.Unknown,
				}, gax.Backoff{
					Initial:    1000 * time.Millisecond,
					Max:        60000 * time.Millisecond,
					Multiplier: 1.30,
				})
			}),
		},
	}
}

func defaultBetaAnalyticsDataRESTCallOptions() *BetaAnalyticsDataCallOptions {
	return &BetaAnalyticsDataCallOptions{
		RunReport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		RunPivotReport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		BatchRunReports: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		BatchRunPivotReports: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		GetMetadata: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		RunRealtimeReport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		CheckCompatibility: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
		},
		CreateAudienceExport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
			gax.WithRetry(func() gax.Retryer {
				return gax.OnHTTPCodes(gax.Backoff{
					Initial:    1000 * time.Millisecond,
					Max:        60000 * time.Millisecond,
					Multiplier: 1.30,
				},
					http.StatusInternalServerError)
			}),
		},
		QueryAudienceExport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
			gax.WithRetry(func() gax.Retryer {
				return gax.OnHTTPCodes(gax.Backoff{
					Initial:    1000 * time.Millisecond,
					Max:        60000 * time.Millisecond,
					Multiplier: 1.30,
				},
					http.StatusInternalServerError)
			}),
		},
		GetAudienceExport: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
			gax.WithRetry(func() gax.Retryer {
				return gax.OnHTTPCodes(gax.Backoff{
					Initial:    1000 * time.Millisecond,
					Max:        60000 * time.Millisecond,
					Multiplier: 1.30,
				},
					http.StatusInternalServerError)
			}),
		},
		ListAudienceExports: []gax.CallOption{
			gax.WithTimeout(60000 * time.Millisecond),
			gax.WithRetry(func() gax.Retryer {
				return gax.OnHTTPCodes(gax.Backoff{
					Initial:    1000 * time.Millisecond,
					Max:        60000 * time.Millisecond,
					Multiplier: 1.30,
				},
					http.StatusInternalServerError)
			}),
		},
	}
}

// internalBetaAnalyticsDataClient is an interface that defines the methods available from Google Analytics Data API.
type internalBetaAnalyticsDataClient interface {
	Close() error
	setGoogleClientInfo(...string)
	Connection() *grpc.ClientConn
	RunReport(context.Context, *datapb.RunReportRequest, ...gax.CallOption) (*datapb.RunReportResponse, error)
	RunPivotReport(context.Context, *datapb.RunPivotReportRequest, ...gax.CallOption) (*datapb.RunPivotReportResponse, error)
	BatchRunReports(context.Context, *datapb.BatchRunReportsRequest, ...gax.CallOption) (*datapb.BatchRunReportsResponse, error)
	BatchRunPivotReports(context.Context, *datapb.BatchRunPivotReportsRequest, ...gax.CallOption) (*datapb.BatchRunPivotReportsResponse, error)
	GetMetadata(context.Context, *datapb.GetMetadataRequest, ...gax.CallOption) (*datapb.Metadata, error)
	RunRealtimeReport(context.Context, *datapb.RunRealtimeReportRequest, ...gax.CallOption) (*datapb.RunRealtimeReportResponse, error)
	CheckCompatibility(context.Context, *datapb.CheckCompatibilityRequest, ...gax.CallOption) (*datapb.CheckCompatibilityResponse, error)
	CreateAudienceExport(context.Context, *datapb.CreateAudienceExportRequest, ...gax.CallOption) (*CreateAudienceExportOperation, error)
	CreateAudienceExportOperation(name string) *CreateAudienceExportOperation
	QueryAudienceExport(context.Context, *datapb.QueryAudienceExportRequest, ...gax.CallOption) (*datapb.QueryAudienceExportResponse, error)
	GetAudienceExport(context.Context, *datapb.GetAudienceExportRequest, ...gax.CallOption) (*datapb.AudienceExport, error)
	ListAudienceExports(context.Context, *datapb.ListAudienceExportsRequest, ...gax.CallOption) *AudienceExportIterator
}

// BetaAnalyticsDataClient is a client for interacting with Google Analytics Data API.
// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
//
// Google Analytics reporting data service.
type BetaAnalyticsDataClient struct {
	// The internal transport-dependent client.
	internalClient internalBetaAnalyticsDataClient

	// The call options for this service.
	CallOptions *BetaAnalyticsDataCallOptions

	// LROClient is used internally to handle long-running operations.
	// It is exposed so that its CallOptions can be modified if required.
	// Users should not Close this client.
	LROClient *lroauto.OperationsClient
}

// Wrapper methods routed to the internal client.

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *BetaAnalyticsDataClient) Close() error {
	return c.internalClient.Close()
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *BetaAnalyticsDataClient) setGoogleClientInfo(keyval ...string) {
	c.internalClient.setGoogleClientInfo(keyval...)
}

// Connection returns a connection to the API service.
//
// Deprecated: Connections are now pooled so this method does not always
// return the same resource.
func (c *BetaAnalyticsDataClient) Connection() *grpc.ClientConn {
	return c.internalClient.Connection()
}

// RunReport returns a customized report of your Google Analytics event data. Reports
// contain statistics derived from data collected by the Google Analytics
// tracking code. The data returned from the API is as a table with columns
// for the requested dimensions and metrics. Metrics are individual
// measurements of user activity on your property, such as active users or
// event count. Dimensions break down metrics across some common criteria,
// such as country or event name.
//
// For a guide to constructing requests & understanding responses, see
// Creating a
// Report (at https://developers.google.com/analytics/devguides/reporting/data/v1/basics).
func (c *BetaAnalyticsDataClient) RunReport(ctx context.Context, req *datapb.RunReportRequest, opts ...gax.CallOption) (*datapb.RunReportResponse, error) {
	return c.internalClient.RunReport(ctx, req, opts...)
}

// RunPivotReport returns a customized pivot report of your Google Analytics event data.
// Pivot reports are more advanced and expressive formats than regular
// reports. In a pivot report, dimensions are only visible if they are
// included in a pivot. Multiple pivots can be specified to further dissect
// your data.
func (c *BetaAnalyticsDataClient) RunPivotReport(ctx context.Context, req *datapb.RunPivotReportRequest, opts ...gax.CallOption) (*datapb.RunPivotReportResponse, error) {
	return c.internalClient.RunPivotReport(ctx, req, opts...)
}

// BatchRunReports returns multiple reports in a batch. All reports must be for the same
// GA4 Property.
func (c *BetaAnalyticsDataClient) BatchRunReports(ctx context.Context, req *datapb.BatchRunReportsRequest, opts ...gax.CallOption) (*datapb.BatchRunReportsResponse, error) {
	return c.internalClient.BatchRunReports(ctx, req, opts...)
}

// BatchRunPivotReports returns multiple pivot reports in a batch. All reports must be for the same
// GA4 Property.
func (c *BetaAnalyticsDataClient) BatchRunPivotReports(ctx context.Context, req *datapb.BatchRunPivotReportsRequest, opts ...gax.CallOption) (*datapb.BatchRunPivotReportsResponse, error) {
	return c.internalClient.BatchRunPivotReports(ctx, req, opts...)
}

// GetMetadata returns metadata for dimensions and metrics available in reporting methods.
// Used to explore the dimensions and metrics. In this method, a Google
// Analytics GA4 Property Identifier is specified in the request, and
// the metadata response includes Custom dimensions and metrics as well as
// Universal metadata.
//
// For example if a custom metric with parameter name levels_unlocked is
// registered to a property, the Metadata response will contain
// customEvent:levels_unlocked. Universal metadata are dimensions and
// metrics applicable to any property such as country and totalUsers.
func (c *BetaAnalyticsDataClient) GetMetadata(ctx context.Context, req *datapb.GetMetadataRequest, opts ...gax.CallOption) (*datapb.Metadata, error) {
	return c.internalClient.GetMetadata(ctx, req, opts...)
}

// RunRealtimeReport returns a customized report of realtime event data for your property.
// Events appear in realtime reports seconds after they have been sent to
// the Google Analytics. Realtime reports show events and usage data for the
// periods of time ranging from the present moment to 30 minutes ago (up to
// 60 minutes for Google Analytics 360 properties).
//
// For a guide to constructing realtime requests & understanding responses,
// see Creating a Realtime
// Report (at https://developers.google.com/analytics/devguides/reporting/data/v1/realtime-basics).
func (c *BetaAnalyticsDataClient) RunRealtimeReport(ctx context.Context, req *datapb.RunRealtimeReportRequest, opts ...gax.CallOption) (*datapb.RunRealtimeReportResponse, error) {
	return c.internalClient.RunRealtimeReport(ctx, req, opts...)
}

// CheckCompatibility this compatibility method lists dimensions and metrics that can be added to
// a report request and maintain compatibility. This method fails if the
// request’s dimensions and metrics are incompatible.
//
// In Google Analytics, reports fail if they request incompatible dimensions
// and/or metrics; in that case, you will need to remove dimensions and/or
// metrics from the incompatible report until the report is compatible.
//
// The Realtime and Core reports have different compatibility rules. This
// method checks compatibility for Core reports.
func (c *BetaAnalyticsDataClient) CheckCompatibility(ctx context.Context, req *datapb.CheckCompatibilityRequest, opts ...gax.CallOption) (*datapb.CheckCompatibilityResponse, error) {
	return c.internalClient.CheckCompatibility(ctx, req, opts...)
}

// CreateAudienceExport creates an audience export for later retrieval. This method quickly returns
// the audience export’s resource name and initiates a long running
// asynchronous request to form an audience export. To export the users in an
// audience export, first create the audience export through this method and
// then send the audience resource name to the QueryAudienceExport method.
//
// See Creating an Audience
// Export (at https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
// for an introduction to Audience Exports with examples.
//
// An audience export is a snapshot of the users currently in the audience at
// the time of audience export creation. Creating audience exports for one
// audience on different days will return different results as users enter and
// exit the audience.
//
// Audiences in Google Analytics 4 allow you to segment your users in the ways
// that are important to your business. To learn more, see
// https://support.google.com/analytics/answer/9267572 (at https://support.google.com/analytics/answer/9267572). Audience exports
// contain the users in each audience.
//
// Audience Export APIs have some methods at alpha and other methods at beta
// stability. The intention is to advance methods to beta stability after some
// feedback and adoption. To give your feedback on this API, complete the
// Google Analytics Audience Export API
// Feedback (at https://forms.gle/EeA5u5LW6PEggtCEA) form.
func (c *BetaAnalyticsDataClient) CreateAudienceExport(ctx context.Context, req *datapb.CreateAudienceExportRequest, opts ...gax.CallOption) (*CreateAudienceExportOperation, error) {
	return c.internalClient.CreateAudienceExport(ctx, req, opts...)
}

// CreateAudienceExportOperation returns a new CreateAudienceExportOperation from a given name.
// The name must be that of a previously created CreateAudienceExportOperation, possibly from a different process.
func (c *BetaAnalyticsDataClient) CreateAudienceExportOperation(name string) *CreateAudienceExportOperation {
	return c.internalClient.CreateAudienceExportOperation(name)
}

// QueryAudienceExport retrieves an audience export of users. After creating an audience, the
// users are not immediately available for exporting. First, a request to
// CreateAudienceExport is necessary to create an audience export of users,
// and then second, this method is used to retrieve the users in the audience
// export.
//
// See Creating an Audience
// Export (at https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
// for an introduction to Audience Exports with examples.
//
// Audiences in Google Analytics 4 allow you to segment your users in the ways
// that are important to your business. To learn more, see
// https://support.google.com/analytics/answer/9267572 (at https://support.google.com/analytics/answer/9267572).
//
// Audience Export APIs have some methods at alpha and other methods at beta
// stability. The intention is to advance methods to beta stability after some
// feedback and adoption. To give your feedback on this API, complete the
// Google Analytics Audience Export API
// Feedback (at https://forms.gle/EeA5u5LW6PEggtCEA) form.
func (c *BetaAnalyticsDataClient) QueryAudienceExport(ctx context.Context, req *datapb.QueryAudienceExportRequest, opts ...gax.CallOption) (*datapb.QueryAudienceExportResponse, error) {
	return c.internalClient.QueryAudienceExport(ctx, req, opts...)
}

// GetAudienceExport gets configuration metadata about a specific audience export. This method
// can be used to understand an audience export after it has been created.
//
// See Creating an Audience
// Export (at https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
// for an introduction to Audience Exports with examples.
//
// Audience Export APIs have some methods at alpha and other methods at beta
// stability. The intention is to advance methods to beta stability after some
// feedback and adoption. To give your feedback on this API, complete the
// Google Analytics Audience Export API
// Feedback (at https://forms.gle/EeA5u5LW6PEggtCEA) form.
func (c *BetaAnalyticsDataClient) GetAudienceExport(ctx context.Context, req *datapb.GetAudienceExportRequest, opts ...gax.CallOption) (*datapb.AudienceExport, error) {
	return c.internalClient.GetAudienceExport(ctx, req, opts...)
}

// ListAudienceExports lists all audience exports for a property. This method can be used for you
// to find and reuse existing audience exports rather than creating
// unnecessary new audience exports. The same audience can have multiple
// audience exports that represent the export of users that were in an
// audience on different days.
//
// See Creating an Audience
// Export (at https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
// for an introduction to Audience Exports with examples.
//
// Audience Export APIs have some methods at alpha and other methods at beta
// stability. The intention is to advance methods to beta stability after some
// feedback and adoption. To give your feedback on this API, complete the
// Google Analytics Audience Export API
// Feedback (at https://forms.gle/EeA5u5LW6PEggtCEA) form.
func (c *BetaAnalyticsDataClient) ListAudienceExports(ctx context.Context, req *datapb.ListAudienceExportsRequest, opts ...gax.CallOption) *AudienceExportIterator {
	return c.internalClient.ListAudienceExports(ctx, req, opts...)
}

// betaAnalyticsDataGRPCClient is a client for interacting with Google Analytics Data API over gRPC transport.
//
// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
type betaAnalyticsDataGRPCClient struct {
	// Connection pool of gRPC connections to the service.
	connPool gtransport.ConnPool

	// Points back to the CallOptions field of the containing BetaAnalyticsDataClient
	CallOptions **BetaAnalyticsDataCallOptions

	// The gRPC API client.
	betaAnalyticsDataClient datapb.BetaAnalyticsDataClient

	// LROClient is used internally to handle long-running operations.
	// It is exposed so that its CallOptions can be modified if required.
	// Users should not Close this client.
	LROClient **lroauto.OperationsClient

	// The x-goog-* metadata to be sent with each request.
	xGoogHeaders []string
}

// NewBetaAnalyticsDataClient creates a new beta analytics data client based on gRPC.
// The returned client must be Closed when it is done being used to clean up its underlying connections.
//
// Google Analytics reporting data service.
func NewBetaAnalyticsDataClient(ctx context.Context, opts ...option.ClientOption) (*BetaAnalyticsDataClient, error) {
	clientOpts := defaultBetaAnalyticsDataGRPCClientOptions()
	if newBetaAnalyticsDataClientHook != nil {
		hookOpts, err := newBetaAnalyticsDataClientHook(ctx, clientHookParams{})
		if err != nil {
			return nil, err
		}
		clientOpts = append(clientOpts, hookOpts...)
	}

	connPool, err := gtransport.DialPool(ctx, append(clientOpts, opts...)...)
	if err != nil {
		return nil, err
	}
	client := BetaAnalyticsDataClient{CallOptions: defaultBetaAnalyticsDataCallOptions()}

	c := &betaAnalyticsDataGRPCClient{
		connPool:                connPool,
		betaAnalyticsDataClient: datapb.NewBetaAnalyticsDataClient(connPool),
		CallOptions:             &client.CallOptions,
	}
	c.setGoogleClientInfo()

	client.internalClient = c

	client.LROClient, err = lroauto.NewOperationsClient(ctx, gtransport.WithConnPool(connPool))
	if err != nil {
		// This error "should not happen", since we are just reusing old connection pool
		// and never actually need to dial.
		// If this does happen, we could leak connp. However, we cannot close conn:
		// If the user invoked the constructor with option.WithGRPCConn,
		// we would close a connection that's still in use.
		// TODO: investigate error conditions.
		return nil, err
	}
	c.LROClient = &client.LROClient
	return &client, nil
}

// Connection returns a connection to the API service.
//
// Deprecated: Connections are now pooled so this method does not always
// return the same resource.
func (c *betaAnalyticsDataGRPCClient) Connection() *grpc.ClientConn {
	return c.connPool.Conn()
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *betaAnalyticsDataGRPCClient) setGoogleClientInfo(keyval ...string) {
	kv := append([]string{"gl-go", gax.GoVersion}, keyval...)
	kv = append(kv, "gapic", getVersionClient(), "gax", gax.Version, "grpc", grpc.Version)
	c.xGoogHeaders = []string{
		"x-goog-api-client", gax.XGoogHeader(kv...),
	}
}

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *betaAnalyticsDataGRPCClient) Close() error {
	return c.connPool.Close()
}

// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
type betaAnalyticsDataRESTClient struct {
	// The http endpoint to connect to.
	endpoint string

	// The http client.
	httpClient *http.Client

	// LROClient is used internally to handle long-running operations.
	// It is exposed so that its CallOptions can be modified if required.
	// Users should not Close this client.
	LROClient **lroauto.OperationsClient

	// The x-goog-* headers to be sent with each request.
	xGoogHeaders []string

	// Points back to the CallOptions field of the containing BetaAnalyticsDataClient
	CallOptions **BetaAnalyticsDataCallOptions
}

// NewBetaAnalyticsDataRESTClient creates a new beta analytics data rest client.
//
// Google Analytics reporting data service.
func NewBetaAnalyticsDataRESTClient(ctx context.Context, opts ...option.ClientOption) (*BetaAnalyticsDataClient, error) {
	clientOpts := append(defaultBetaAnalyticsDataRESTClientOptions(), opts...)
	httpClient, endpoint, err := httptransport.NewClient(ctx, clientOpts...)
	if err != nil {
		return nil, err
	}

	callOpts := defaultBetaAnalyticsDataRESTCallOptions()
	c := &betaAnalyticsDataRESTClient{
		endpoint:    endpoint,
		httpClient:  httpClient,
		CallOptions: &callOpts,
	}
	c.setGoogleClientInfo()

	lroOpts := []option.ClientOption{
		option.WithHTTPClient(httpClient),
		option.WithEndpoint(endpoint),
	}
	opClient, err := lroauto.NewOperationsRESTClient(ctx, lroOpts...)
	if err != nil {
		return nil, err
	}
	c.LROClient = &opClient

	return &BetaAnalyticsDataClient{internalClient: c, CallOptions: callOpts}, nil
}

func defaultBetaAnalyticsDataRESTClientOptions() []option.ClientOption {
	return []option.ClientOption{
		internaloption.WithDefaultEndpoint("https://analyticsdata.googleapis.com"),
		internaloption.WithDefaultEndpointTemplate("https://analyticsdata.UNIVERSE_DOMAIN"),
		internaloption.WithDefaultMTLSEndpoint("https://analyticsdata.mtls.googleapis.com"),
		internaloption.WithDefaultUniverseDomain("googleapis.com"),
		internaloption.WithDefaultAudience("https://analyticsdata.googleapis.com/"),
		internaloption.WithDefaultScopes(DefaultAuthScopes()...),
		internaloption.EnableNewAuthLibrary(),
	}
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *betaAnalyticsDataRESTClient) setGoogleClientInfo(keyval ...string) {
	kv := append([]string{"gl-go", gax.GoVersion}, keyval...)
	kv = append(kv, "gapic", getVersionClient(), "gax", gax.Version, "rest", "UNKNOWN")
	c.xGoogHeaders = []string{
		"x-goog-api-client", gax.XGoogHeader(kv...),
	}
}

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *betaAnalyticsDataRESTClient) Close() error {
	// Replace httpClient with nil to force cleanup.
	c.httpClient = nil
	return nil
}

// Connection returns a connection to the API service.
//
// Deprecated: This method always returns nil.
func (c *betaAnalyticsDataRESTClient) Connection() *grpc.ClientConn {
	return nil
}
func (c *betaAnalyticsDataGRPCClient) RunReport(ctx context.Context, req *datapb.RunReportRequest, opts ...gax.CallOption) (*datapb.RunReportResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).RunReport[0:len((*c.CallOptions).RunReport):len((*c.CallOptions).RunReport)], opts...)
	var resp *datapb.RunReportResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.RunReport(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) RunPivotReport(ctx context.Context, req *datapb.RunPivotReportRequest, opts ...gax.CallOption) (*datapb.RunPivotReportResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).RunPivotReport[0:len((*c.CallOptions).RunPivotReport):len((*c.CallOptions).RunPivotReport)], opts...)
	var resp *datapb.RunPivotReportResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.RunPivotReport(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) BatchRunReports(ctx context.Context, req *datapb.BatchRunReportsRequest, opts ...gax.CallOption) (*datapb.BatchRunReportsResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).BatchRunReports[0:len((*c.CallOptions).BatchRunReports):len((*c.CallOptions).BatchRunReports)], opts...)
	var resp *datapb.BatchRunReportsResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.BatchRunReports(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) BatchRunPivotReports(ctx context.Context, req *datapb.BatchRunPivotReportsRequest, opts ...gax.CallOption) (*datapb.BatchRunPivotReportsResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).BatchRunPivotReports[0:len((*c.CallOptions).BatchRunPivotReports):len((*c.CallOptions).BatchRunPivotReports)], opts...)
	var resp *datapb.BatchRunPivotReportsResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.BatchRunPivotReports(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) GetMetadata(ctx context.Context, req *datapb.GetMetadataRequest, opts ...gax.CallOption) (*datapb.Metadata, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetMetadata[0:len((*c.CallOptions).GetMetadata):len((*c.CallOptions).GetMetadata)], opts...)
	var resp *datapb.Metadata
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.GetMetadata(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) RunRealtimeReport(ctx context.Context, req *datapb.RunRealtimeReportRequest, opts ...gax.CallOption) (*datapb.RunRealtimeReportResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).RunRealtimeReport[0:len((*c.CallOptions).RunRealtimeReport):len((*c.CallOptions).RunRealtimeReport)], opts...)
	var resp *datapb.RunRealtimeReportResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.RunRealtimeReport(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) CheckCompatibility(ctx context.Context, req *datapb.CheckCompatibilityRequest, opts ...gax.CallOption) (*datapb.CheckCompatibilityResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).CheckCompatibility[0:len((*c.CallOptions).CheckCompatibility):len((*c.CallOptions).CheckCompatibility)], opts...)
	var resp *datapb.CheckCompatibilityResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.CheckCompatibility(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) CreateAudienceExport(ctx context.Context, req *datapb.CreateAudienceExportRequest, opts ...gax.CallOption) (*CreateAudienceExportOperation, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).CreateAudienceExport[0:len((*c.CallOptions).CreateAudienceExport):len((*c.CallOptions).CreateAudienceExport)], opts...)
	var resp *longrunningpb.Operation
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.CreateAudienceExport(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return &CreateAudienceExportOperation{
		lro: longrunning.InternalNewOperation(*c.LROClient, resp),
	}, nil
}

func (c *betaAnalyticsDataGRPCClient) QueryAudienceExport(ctx context.Context, req *datapb.QueryAudienceExportRequest, opts ...gax.CallOption) (*datapb.QueryAudienceExportResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).QueryAudienceExport[0:len((*c.CallOptions).QueryAudienceExport):len((*c.CallOptions).QueryAudienceExport)], opts...)
	var resp *datapb.QueryAudienceExportResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.QueryAudienceExport(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) GetAudienceExport(ctx context.Context, req *datapb.GetAudienceExportRequest, opts ...gax.CallOption) (*datapb.AudienceExport, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetAudienceExport[0:len((*c.CallOptions).GetAudienceExport):len((*c.CallOptions).GetAudienceExport)], opts...)
	var resp *datapb.AudienceExport
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = c.betaAnalyticsDataClient.GetAudienceExport(ctx, req, settings.GRPC...)
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *betaAnalyticsDataGRPCClient) ListAudienceExports(ctx context.Context, req *datapb.ListAudienceExportsRequest, opts ...gax.CallOption) *AudienceExportIterator {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListAudienceExports[0:len((*c.CallOptions).ListAudienceExports):len((*c.CallOptions).ListAudienceExports)], opts...)
	it := &AudienceExportIterator{}
	req = proto.Clone(req).(*datapb.ListAudienceExportsRequest)
	it.InternalFetch = func(pageSize int, pageToken string) ([]*datapb.AudienceExport, string, error) {
		resp := &datapb.ListAudienceExportsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			var err error
			resp, err = c.betaAnalyticsDataClient.ListAudienceExports(ctx, req, settings.GRPC...)
			return err
		}, opts...)
		if err != nil {
			return nil, "", err
		}

		it.Response = resp
		return resp.GetAudienceExports(), resp.GetNextPageToken(), nil
	}
	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

// RunReport returns a customized report of your Google Analytics event data. Reports
// contain statistics derived from data collected by the Google Analytics
// tracking code. The data returned from the API is as a table with columns
// for the requested dimensions and metrics. Metrics are individual
// measurements of user activity on your property, such as active users or
// event count. Dimensions break down metrics across some common criteria,
// such as country or event name.
//
// For a guide to constructing requests & understanding responses, see
// Creating a
// Report (at https://developers.google.com/analytics/devguides/reporting/data/v1/basics).
func (c *betaAnalyticsDataRESTClient) RunReport(ctx context.Context, req *datapb.RunReportRequest, opts ...gax.CallOption) (*datapb.RunReportResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v:runReport", req.GetProperty())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).RunReport[0:len((*c.CallOptions).RunReport):len((*c.CallOptions).RunReport)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.RunReportResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// RunPivotReport returns a customized pivot report of your Google Analytics event data.
// Pivot reports are more advanced and expressive formats than regular
// reports. In a pivot report, dimensions are only visible if they are
// included in a pivot. Multiple pivots can be specified to further dissect
// your data.
func (c *betaAnalyticsDataRESTClient) RunPivotReport(ctx context.Context, req *datapb.RunPivotReportRequest, opts ...gax.CallOption) (*datapb.RunPivotReportResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v:runPivotReport", req.GetProperty())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).RunPivotReport[0:len((*c.CallOptions).RunPivotReport):len((*c.CallOptions).RunPivotReport)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.RunPivotReportResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// BatchRunReports returns multiple reports in a batch. All reports must be for the same
// GA4 Property.
func (c *betaAnalyticsDataRESTClient) BatchRunReports(ctx context.Context, req *datapb.BatchRunReportsRequest, opts ...gax.CallOption) (*datapb.BatchRunReportsResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v:batchRunReports", req.GetProperty())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).BatchRunReports[0:len((*c.CallOptions).BatchRunReports):len((*c.CallOptions).BatchRunReports)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.BatchRunReportsResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// BatchRunPivotReports returns multiple pivot reports in a batch. All reports must be for the same
// GA4 Property.
func (c *betaAnalyticsDataRESTClient) BatchRunPivotReports(ctx context.Context, req *datapb.BatchRunPivotReportsRequest, opts ...gax.CallOption) (*datapb.BatchRunPivotReportsResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v:batchRunPivotReports", req.GetProperty())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).BatchRunPivotReports[0:len((*c.CallOptions).BatchRunPivotReports):len((*c.CallOptions).BatchRunPivotReports)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.BatchRunPivotReportsResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetMetadata returns metadata for dimensions and metrics available in reporting methods.
// Used to explore the dimensions and metrics. In this method, a Google
// Analytics GA4 Property Identifier is specified in the request, and
// the metadata response includes Custom dimensions and metrics as well as
// Universal metadata.
//
// For example if a custom metric with parameter name levels_unlocked is
// registered to a property, the Metadata response will contain
// customEvent:levels_unlocked. Universal metadata are dimensions and
// metrics applicable to any property such as country and totalUsers.
func (c *betaAnalyticsDataRESTClient) GetMetadata(ctx context.Context, req *datapb.GetMetadataRequest, opts ...gax.CallOption) (*datapb.Metadata, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetMetadata[0:len((*c.CallOptions).GetMetadata):len((*c.CallOptions).GetMetadata)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.Metadata{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// RunRealtimeReport returns a customized report of realtime event data for your property.
// Events appear in realtime reports seconds after they have been sent to
// the Google Analytics. Realtime reports show events and usage data for the
// periods of time ranging from the present moment to 30 minutes ago (up to
// 60 minutes for Google Analytics 360 properties).
//
// For a guide to constructing realtime requests & understanding responses,
// see Creating a Realtime
// Report (at https://developers.google.com/analytics/devguides/reporting/data/v1/realtime-basics).
func (c *betaAnalyticsDataRESTClient) RunRealtimeReport(ctx context.Context, req *datapb.RunRealtimeReportRequest, opts ...gax.CallOption) (*datapb.RunRealtimeReportResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v:runRealtimeReport", req.GetProperty())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).RunRealtimeReport[0:len((*c.CallOptions).RunRealtimeReport):len((*c.CallOptions).RunRealtimeReport)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.RunRealtimeReportResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// CheckCompatibility this compatibility method lists dimensions and metrics that can be added to
// a report request and maintain compatibility. This method fails if the
// request’s dimensions and metrics are incompatible.
//
// In Google Analytics, reports fail if they request incompatible dimensions
// and/or metrics; in that case, you will need to remove dimensions and/or
// metrics from the incompatible report until the report is compatible.
//
// The Realtime and Core reports have different compatibility rules. This
// method checks compatibility for Core reports.
func (c *betaAnalyticsDataRESTClient) CheckCompatibility(ctx context.Context, req *datapb.CheckCompatibilityRequest, opts ...gax.CallOption) (*datapb.CheckCompatibilityResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v:checkCompatibility", req.GetProperty())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "property", url.QueryEscape(req.GetProperty()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).CheckCompatibility[0:len((*c.CallOptions).CheckCompatibility):len((*c.CallOptions).CheckCompatibility)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.CheckCompatibilityResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// CreateAudienceExport creates an audience export for later retrieval. This method quickly returns
// the audience export’s resource name and initiates a long running
// asynchronous request to form an audience export. To export the users in an
// audience export, first create the audience export through this method and
// then send the audience resource name to the QueryAudienceExport method.
//
// See Creating an Audience
// Export (at https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
// for an introduction to Audience Exports with examples.
//
// An audience export is a snapshot of the users currently in the audience at
// the time of audience export creation. Creating audience exports for one
// audience on different days will return different results as users enter and
// exit the audience.
//
// Audiences in Google Analytics 4 allow you to segment your users in the ways
// that are important to your business. To learn more, see
// https://support.google.com/analytics/answer/9267572 (at https://support.google.com/analytics/answer/9267572). Audience exports
// contain the users in each audience.
//
// Audience Export APIs have some methods at alpha and other methods at beta
// stability. The intention is to advance methods to beta stability after some
// feedback and adoption. To give your feedback on this API, complete the
// Google Analytics Audience Export API
// Feedback (at https://forms.gle/EeA5u5LW6PEggtCEA) form.
func (c *betaAnalyticsDataRESTClient) CreateAudienceExport(ctx context.Context, req *datapb.CreateAudienceExportRequest, opts ...gax.CallOption) (*CreateAudienceExportOperation, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	body := req.GetAudienceExport()
	jsonReq, err := m.Marshal(body)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v/audienceExports", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &longrunningpb.Operation{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}

	override := fmt.Sprintf("/v1beta/%s", resp.GetName())
	return &CreateAudienceExportOperation{
		lro:      longrunning.InternalNewOperation(*c.LROClient, resp),
		pollPath: override,
	}, nil
}

// QueryAudienceExport retrieves an audience export of users. After creating an audience, the
// users are not immediately available for exporting. First, a request to
// CreateAudienceExport is necessary to create an audience export of users,
// and then second, this method is used to retrieve the users in the audience
// export.
//
// See Creating an Audience
// Export (at https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
// for an introduction to Audience Exports with examples.
//
// Audiences in Google Analytics 4 allow you to segment your users in the ways
// that are important to your business. To learn more, see
// https://support.google.com/analytics/answer/9267572 (at https://support.google.com/analytics/answer/9267572).
//
// Audience Export APIs have some methods at alpha and other methods at beta
// stability. The intention is to advance methods to beta stability after some
// feedback and adoption. To give your feedback on this API, complete the
// Google Analytics Audience Export API
// Feedback (at https://forms.gle/EeA5u5LW6PEggtCEA) form.
func (c *betaAnalyticsDataRESTClient) QueryAudienceExport(ctx context.Context, req *datapb.QueryAudienceExportRequest, opts ...gax.CallOption) (*datapb.QueryAudienceExportResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v:query", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).QueryAudienceExport[0:len((*c.CallOptions).QueryAudienceExport):len((*c.CallOptions).QueryAudienceExport)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.QueryAudienceExportResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetAudienceExport gets configuration metadata about a specific audience export. This method
// can be used to understand an audience export after it has been created.
//
// See Creating an Audience
// Export (at https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
// for an introduction to Audience Exports with examples.
//
// Audience Export APIs have some methods at alpha and other methods at beta
// stability. The intention is to advance methods to beta stability after some
// feedback and adoption. To give your feedback on this API, complete the
// Google Analytics Audience Export API
// Feedback (at https://forms.gle/EeA5u5LW6PEggtCEA) form.
func (c *betaAnalyticsDataRESTClient) GetAudienceExport(ctx context.Context, req *datapb.GetAudienceExportRequest, opts ...gax.CallOption) (*datapb.AudienceExport, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1beta/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetAudienceExport[0:len((*c.CallOptions).GetAudienceExport):len((*c.CallOptions).GetAudienceExport)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &datapb.AudienceExport{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		httpRsp, err := c.httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		defer httpRsp.Body.Close()

		if err = googleapi.CheckResponse(httpRsp); err != nil {
			return err
		}

		buf, err := io.ReadAll(httpRsp.Body)
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListAudienceExports lists all audience exports for a property. This method can be used for you
// to find and reuse existing audience exports rather than creating
// unnecessary new audience exports. The same audience can have multiple
// audience exports that represent the export of users that were in an
// audience on different days.
//
// See Creating an Audience
// Export (at https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
// for an introduction to Audience Exports with examples.
//
// Audience Export APIs have some methods at alpha and other methods at beta
// stability. The intention is to advance methods to beta stability after some
// feedback and adoption. To give your feedback on this API, complete the
// Google Analytics Audience Export API
// Feedback (at https://forms.gle/EeA5u5LW6PEggtCEA) form.
func (c *betaAnalyticsDataRESTClient) ListAudienceExports(ctx context.Context, req *datapb.ListAudienceExportsRequest, opts ...gax.CallOption) *AudienceExportIterator {
	it := &AudienceExportIterator{}
	req = proto.Clone(req).(*datapb.ListAudienceExportsRequest)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	it.InternalFetch = func(pageSize int, pageToken string) ([]*datapb.AudienceExport, string, error) {
		resp := &datapb.ListAudienceExportsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		baseUrl, err := url.Parse(c.endpoint)
		if err != nil {
			return nil, "", err
		}
		baseUrl.Path += fmt.Sprintf("/v1beta/%v/audienceExports", req.GetParent())

		params := url.Values{}
		params.Add("$alt", "json;enum-encoding=int")
		if req.GetPageSize() != 0 {
			params.Add("pageSize", fmt.Sprintf("%v", req.GetPageSize()))
		}
		if req.GetPageToken() != "" {
			params.Add("pageToken", fmt.Sprintf("%v", req.GetPageToken()))
		}

		baseUrl.RawQuery = params.Encode()

		// Build HTTP headers from client and context metadata.
		hds := append(c.xGoogHeaders, "Content-Type", "application/json")
		headers := gax.BuildHeaders(ctx, hds...)
		e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			if settings.Path != "" {
				baseUrl.Path = settings.Path
			}
			httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
			if err != nil {
				return err
			}
			httpReq.Header = headers

			httpRsp, err := c.httpClient.Do(httpReq)
			if err != nil {
				return err
			}
			defer httpRsp.Body.Close()

			if err = googleapi.CheckResponse(httpRsp); err != nil {
				return err
			}

			buf, err := io.ReadAll(httpRsp.Body)
			if err != nil {
				return err
			}

			if err := unm.Unmarshal(buf, resp); err != nil {
				return err
			}

			return nil
		}, opts...)
		if e != nil {
			return nil, "", e
		}
		it.Response = resp
		return resp.GetAudienceExports(), resp.GetNextPageToken(), nil
	}

	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

// CreateAudienceExportOperation returns a new CreateAudienceExportOperation from a given name.
// The name must be that of a previously created CreateAudienceExportOperation, possibly from a different process.
func (c *betaAnalyticsDataGRPCClient) CreateAudienceExportOperation(name string) *CreateAudienceExportOperation {
	return &CreateAudienceExportOperation{
		lro: longrunning.InternalNewOperation(*c.LROClient, &longrunningpb.Operation{Name: name}),
	}
}

// CreateAudienceExportOperation returns a new CreateAudienceExportOperation from a given name.
// The name must be that of a previously created CreateAudienceExportOperation, possibly from a different process.
func (c *betaAnalyticsDataRESTClient) CreateAudienceExportOperation(name string) *CreateAudienceExportOperation {
	override := fmt.Sprintf("/v1beta/%s", name)
	return &CreateAudienceExportOperation{
		lro:      longrunning.InternalNewOperation(*c.LROClient, &longrunningpb.Operation{Name: name}),
		pollPath: override,
	}
}
